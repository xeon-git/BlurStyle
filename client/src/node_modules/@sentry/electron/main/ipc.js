Object.defineProperty(exports, "__esModule", { value: true });
exports.configureIPC = exports.handleScope = exports.handleEvent = void 0;
const core_1 = require("@sentry/core");
const utils_1 = require("@sentry/utils");
const electron_1 = require("electron");
const common_1 = require("../common");
const electron_normalize_1 = require("./electron-normalize");
/**
 * Handle events from the renderer processes
 */
function handleEvent(options, jsonEvent, contents) {
    var _a;
    let event;
    try {
        event = JSON.parse(jsonEvent);
    }
    catch (_b) {
        utils_1.logger.warn('sentry-electron received an invalid event message');
        return;
    }
    const process = contents ? ((_a = options === null || options === void 0 ? void 0 : options.getRendererName) === null || _a === void 0 ? void 0 : _a.call(options, contents)) || 'renderer' : 'renderer';
    (0, core_1.captureEvent)((0, common_1.mergeEvents)(event, { tags: { 'event.process': process } }));
}
exports.handleEvent = handleEvent;
/** Is object defined and has keys */
function hasKeys(obj) {
    return obj != undefined && Object.keys(obj).length > 0;
}
/**
 * Handle scope updates from renderer processes
 */
function handleScope(options, jsonScope) {
    let rendererScope;
    try {
        rendererScope = JSON.parse(jsonScope);
    }
    catch (_a) {
        utils_1.logger.warn('sentry-electron received an invalid scope message');
        return;
    }
    const sentScope = core_1.Scope.clone(rendererScope);
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    (0, core_1.configureScope)((scope) => {
        if (hasKeys(sentScope._user)) {
            scope.setUser(sentScope._user);
        }
        if (hasKeys(sentScope._tags)) {
            scope.setTags(sentScope._tags);
        }
        if (hasKeys(sentScope._extra)) {
            scope.setExtras(sentScope._extra);
        }
        const breadcrumb = sentScope._breadcrumbs.pop();
        if (breadcrumb) {
            scope.addBreadcrumb(breadcrumb, (options === null || options === void 0 ? void 0 : options.maxBreadcrumbs) || 100);
        }
    });
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
exports.handleScope = handleScope;
/** Enables Electron protocol handling */
function configureProtocol(options) {
    if (electron_1.app.isReady()) {
        throw new utils_1.SentryError("Sentry SDK should be initialized before the Electron app 'ready' event is fired");
    }
    electron_1.protocol.registerSchemesAsPrivileged([
        {
            scheme: common_1.PROTOCOL_SCHEME,
            privileges: { bypassCSP: true, corsEnabled: true, supportFetchAPI: true },
        },
    ]);
    electron_normalize_1.whenAppReady
        .then(() => {
        for (const sesh of options.getSessions()) {
            sesh.protocol.registerStringProtocol(common_1.PROTOCOL_SCHEME, (request, callback) => {
                var _a, _b;
                const data = (_b = (_a = request.uploadData) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.bytes.toString();
                if (request.url.startsWith(`${common_1.PROTOCOL_SCHEME}://${common_1.IPCChannel.EVENT}`) && data) {
                    handleEvent(options, data);
                }
                else if (request.url.startsWith(`${common_1.PROTOCOL_SCHEME}://${common_1.IPCChannel.SCOPE}`) && data) {
                    handleScope(options, data);
                }
                callback('');
            });
        }
    })
        .catch((error) => utils_1.logger.error(error));
}
/**
 * Hooks IPC for communication with the renderer processes
 */
function configureClassic(options) {
    electron_1.ipcMain.on(common_1.IPCChannel.EVENT, ({ sender }, jsonEvent) => handleEvent(options, jsonEvent, sender));
    electron_1.ipcMain.on(common_1.IPCChannel.SCOPE, (_, jsonScope) => handleScope(options, jsonScope));
}
/** Sets up communication channels with the renderer */
function configureIPC(options) {
    if (!(0, electron_normalize_1.supportsFullProtocol)() && options.ipcMode === common_1.IPCMode.Protocol) {
        throw new utils_1.SentryError('IPCMode.Protocol is only supported in Electron >= v5');
    }
    // eslint-disable-next-line no-bitwise
    if ((0, electron_normalize_1.supportsFullProtocol)() && (options.ipcMode & common_1.IPCMode.Protocol) > 0) {
        configureProtocol(options);
    }
    // eslint-disable-next-line no-bitwise
    if ((options.ipcMode & common_1.IPCMode.Classic) > 0) {
        configureClassic(options);
    }
}
exports.configureIPC = configureIPC;
//# sourceMappingURL=ipc.js.map