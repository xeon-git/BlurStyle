{"version":3,"file":"sessions.js","sourceRoot":"","sources":["../../src/main/sessions.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { makeSession, updateSession } from '@sentry/hub';\nimport { flush, NodeClient } from '@sentry/node';\nimport { SerializedSession, SessionContext, SessionStatus } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport { sentryCachePath } from './fs';\nimport { Store } from './store';\n\nconst PERSIST_INTERVAL_MS = 60_000;\n\n/** Stores the app session in case of termination due to main process crash or app killed */\nconst sessionStore = new Store<SessionContext | undefined>(sentryCachePath, 'session', undefined);\n\n/** Previous session that did not exit cleanly */\nlet previousSession = sessionStore.get();\nconst previousSessionModified = sessionStore.getModifiedDate();\n\nlet persistTimer: NodeJS.Timer | undefined;\n\n/** Starts a session */\nexport function startSession(): void {\n  const hub = getCurrentHub();\n  sessionStore.set(hub.startSession());\n\n  // Every PERSIST_INTERVAL, write the session to disk\n  persistTimer = setInterval(() => {\n    const currentSession = hub.getScope()?.getSession();\n    // Only bother saving if it hasn't already ended\n    if (currentSession && currentSession.status === 'ok') {\n      sessionStore.set(currentSession);\n    }\n  }, PERSIST_INTERVAL_MS);\n}\n\n/** Cleanly ends a session */\nexport async function endSession(): Promise<void> {\n  // Once the session had ended there is no point persisting it\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const hub = getCurrentHub();\n  const session = hub.getScope()?.getSession();\n\n  if (session) {\n    if (session.status === 'ok') {\n      logger.log('Ending session');\n      hub.endSession();\n    } else {\n      logger.log('Session was already ended');\n    }\n  } else {\n    logger.log('No session');\n  }\n\n  sessionStore.set(undefined, true);\n\n  await flush();\n}\n\n/** Determines if a Date is likely to have occurred in the previous uncompleted session */\nexport function unreportedDuringLastSession(crashDate: Date | undefined): boolean {\n  if (!crashDate) {\n    return false;\n  }\n\n  // There is no previous session\n  if (!previousSessionModified) {\n    return false;\n  }\n\n  const previousSessionModifiedTime = previousSessionModified.getTime();\n  const crashTime = crashDate.getTime();\n\n  // Session could have run until modified time + persist interval\n  const prevSessionEnd = previousSessionModifiedTime + PERSIST_INTERVAL_MS;\n\n  // Event cannot have occurred before last persist time, We add a 2 second overlap to be sure\n  const lastPersist = previousSessionModifiedTime - 2_000;\n\n  // If the crash occurred between the last persist and estimated end of session\n  return crashTime > lastPersist && crashTime < prevSessionEnd;\n}\n\n/** Checks if the previous session needs sending as crashed or abnormal  */\nexport async function checkPreviousSession(crashed: boolean): Promise<void> {\n  const client = getCurrentHub().getClient<NodeClient>();\n\n  if (previousSession && client) {\n    // Ignore if the previous session is already ended\n    if (previousSession.status !== 'ok') {\n      previousSession = undefined;\n      return;\n    }\n\n    const status: SessionStatus = crashed ? 'crashed' : 'abnormal';\n\n    logger.log(`Found previous ${status} session`);\n\n    const sesh = makeSession(previousSession);\n\n    updateSession(sesh, {\n      status,\n      errors: (sesh.errors || 0) + 1,\n      release: (previousSession as unknown as SerializedSession).attrs?.release,\n      environment: (previousSession as unknown as SerializedSession).attrs?.environment,\n    });\n\n    await client.sendSession(sesh);\n\n    previousSession = undefined;\n  }\n}\n\n/** Sets the current session as crashed */\nexport function sessionCrashed(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  logger.log('Session Crashed');\n  const hub = getCurrentHub();\n  const session = hub.getScope()?.getSession();\n\n  if (!session) {\n    logger.log('No session to update');\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as crashed');\n    updateSession(session, { status: 'crashed', errors: (session.errors += 1) });\n  } else {\n    logger.log('Session already ended');\n  }\n\n  hub.captureSession();\n}\n"]}